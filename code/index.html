<!DOCTYPE html>
<html lang="fr">

   <head>
      <meta charset="utf-8">
      <title>Accidentologie Paris</title>
      <script src="https://d3js.org/d3.v4.min.js"></script>
      <style type="text/css">
         /* No style rules here yet */
      </style>
   </head>

   <body>

      <div>
         <input id="slider" type="range" value="1" min="1" max="52" step="1" />
         <span id="week">week</span>
      </div>

      <script>
         var width = 1280,
            height = 720;

         var svg = d3.select("body")
            .append("svg")
            .attr("width", width)
            .attr("height", height);
            
	    // add a rectangle to see the bound of the svg
  		svg.append("rect").attr('width', width).attr('height', height)
	    .style('stroke', 'black').style('fill', 'none');

         var g = svg.append("g");

         var color = d3.scaleQuantize()
            .range(["rgb(237,248,233)",
               "rgb(186,228,179)",
               "rgb(116,196,118)",
               "rgb(49,163,84)",
               "rgb(0,109,44)"
            ]);

         //Define map projection
         /*var projection = d3.geoConicConformal().center([2.287592,
            48.862725
         ]).scale(
            150000);*/
         /*
		var projection = d3.geoMercator();
         
        // set projection parameters
		projection
		  .scale(15000)
		  .center([2.287592,48.86272])

         var path = d3.geoPath() // d3.geo.path avec d3 version 3
            .projection(projection);
*/
         var tooltip = d3.select('body').append('div')
            .attr('class', 'hidden tooltip');

         function known(d, week) {
            if (d.properties.tab != undefined) {
               var val = d.properties.tab[week];
            }
            return val
         };
         
         
		///*******************************************///
		///********** Partie accidentologie **********///
		///*******************************************///
        
        // Convertie un intervalle d'heure en un intervalle de minute
     	function getMinutesInterval(hoursInterval) {
			minutesInterval = [];
			minutesInterval[0] = (parseInt(hoursInterval[0].slice(0,2)) * 60) + parseInt(hoursInterval[0].slice(3,5));
			minutesInterval[1] = (parseInt(hoursInterval[1].slice(0,2)) * 60) + parseInt(hoursInterval[1].slice(3,5));
			return minutesInterval;
		}


		// Renvoie si oui ou non une heure est incluse dans un intervalle d'heure
		function checkHoursInterval(hour, interval) {
			h = (parseInt(hour.slice(0,2)) * 60) + (parseInt(hour.slice(3,5)));
			if(h >= interval[0] && h <= interval[1]) {
				return true;
			}
			return false;
		}
		
		
		// Convertie un intervalle de date en un intervalle d'heure
		function getDaysInterval(dateInterval) {
			daysInterval = [];
			daysInterval[0] = (parseInt(dateInterval[0].slice(0,4)) * 365.2425) + (parseInt(dateInterval[0].slice(5,7)) * 30.44) + parseInt(dateInterval[0].slice(8,10));
			daysInterval[1] = (parseInt(dateInterval[1].slice(0,4)) * 365.2425) + (parseInt(dateInterval[1].slice(5,7)) * 30.44) + parseInt(dateInterval[1].slice(8,10));
			return daysInterval;
		}


		// Renvoie si oui ou non une date est incluse dans un intervalle de date
		function checkDaysInterval(date, interval) {
			d = (parseInt(date.slice(0,4)) * 365.2425) + (parseInt(date.slice(5,7)) * 30.44) + parseInt(date.slice(8,10));
			if(d >= interval[0] && d <= interval[1]) {
				return true;
			}
			return false;
		}
		
        
		 // Affecte un accident a une zone
		 function affectZone(accident, rayon) {
		 	for(var i=0; i < zones.length; ++i) {
		 		center = zones[i].center;
		 		x = accident.properties.wgs[0];
		 		y = accident.properties.wgs[1];
			 	// check coordonnee en X et Y
			 	if(x <= center[0]+rayon && x >= center[0]-rayon && y <= center[1]+rayon && y >= center[1]-rayon) {
		 			liste_accidents.push({ "zone": i, "accident": accident });
		 			return 0;
			 	}
			}
		
			// Aucune zone ne convient, on en creer donc une nouvelle
			zones.push({ "center": accident.properties.wgs, "stats" : { "nbAcc": 0, "Indem": 0, "BL": 0, "BH": 0, "Fuite": 0, "Conducteur": 0, "Passage": 0, "Pieton": 0, "Velo": 0, "Scooter": 0, "Moto": 0, "Voiture": 0, "VehiculeUtilitaire": 0, "BusCar": 0, "PoidsLourd": 0, "Tram": 0  } });
			id = zones.length-1;
			liste_accidents.push({ "zone": id, "accident": accident });
		 }
		 
		 
		 // Recupere toutes les zones d'accident
		 function getZones(accidents, rayon, arrondissements, annees, mois, jours, hoursInterval, dateInterval) {
		 	// On convertit l'intervalle d'heure en minute
		 	minutesInterval = []
		 	if(hoursInterval.length != 0) {
		 		minutesInterval = getMinutesInterval(hoursInterval);
		 	}
		 	
		 	// On convertit l'intervalle de date en jours
		 	daysInterval = []
		 	if(dateInterval.length != 0) {
		 		daysInterval = getDaysInterval(dateInterval);
		 	}
		 	
		 	// Creation des zones d'accident
		 	for(var i = 0; i < accidents.length; ++i) {
		 		// Filtre par arrondissement
		 		if(arrondissements.length == 0 || arrondissements.indexOf(accidents[i].properties.cp) != -1) {
		 			// Filtre par un intervalle de date (priorite) ou annees - mois - jours en particulier
		 			if(daysInterval.length != 0) {
		 				// Filtre par un intervalle de date
		 				if(checkDaysInterval(accidents[i].properties.date, daysInterval)) {
			 				// Filtre par un intervalle d'heure
			 				if(minutesInterval.length == 0 || checkHoursInterval(accidents[i].properties.heure, minutesInterval)) {
			 					id = affectZone(accidents[i], rayon);
			 				}
		 				}
		 			} else {	// Filtre par annees - mois - jours en particulier
			 			// Filtre par annee
			 			if(annees.length == 0 || annees.indexOf(accidents[i].properties.date.slice(0,4)) != -1) {
			 				// Filtre par mois
			 				if(mois.length == 0 || mois.indexOf(accidents[i].properties.date.slice(5,7)) != -1) {
			 					// Filtre par jours
			 					if(jours.length == 0 || jours.indexOf(accidents[i].properties.date.slice(8,10)) != -1) {
			 						// Filtre par un intervalle d'heure
			 						if(minutesInterval.length == 0 || checkHoursInterval(accidents[i].properties.heure, minutesInterval)) {
		 								id = affectZone(accidents[i], rayon);
		 							}
			 					}
			 				}
		 				}
	 				}
	 			}
		 	}
		 	
		 	
		 	// Ajout des statistiques aux zones
		 	for(var i = 0; i < liste_accidents.length; ++i) {
		 		// Mise a jour du nombre d'accident par zone
		 		zones[liste_accidents[i].zone].stats.nbAcc++;
		 		
		 		// Mise a jour de la gravite des blessures lors des accidents d'une zone (Indem, BL, BH)
		 		accident = liste_accidents[i].accident;
		 		if(accident.usager_1_grav == "Indem") { zones[liste_accidents[i].zone].stats.Indem++; }
		 		if(accident.usager_1_grav == "BL") { zones[liste_accidents[i].zone].stats.BL++; }
		 		if(accident.usager_1_grav == "BH") { zones[liste_accidents[i].zone].stats.BH++; }
		 		if(accident.usager_2_grav == "Indem") { zones[liste_accidents[i].zone].stats.Indem++; }
		 		if(accident.usager_2_grav == "BL") { zones[liste_accidents[i].zone].stats.BL++; }
		 		if(accident.usager_2_grav == "BH") { zones[liste_accidents[i].zone].stats.BH++; }
		 		if(accident.usager_3_grav == "Indem") { zones[liste_accidents[i].zone].stats.Indem++; }
		 		if(accident.usager_3_grav == "BL") { zones[liste_accidents[i].zone].stats.BL++; }
		 		if(accident.usager_3_grav == "BH") { zones[liste_accidents[i].zone].stats.BH++; }
		 		if(accident.usager_4_grav == "Indem") { zones[liste_accidents[i].zone].stats.Indem++; }
		 		if(accident.usager_4_grav == "BL") { zones[liste_accidents[i].zone].stats.BL++; }
		 		if(accident.usager_4_grav == "BH") { zones[liste_accidents[i].zone].stats.BH++; }
		 		
		 		// Nombre de vehicule en fuite
		 		if(accident.usager_1_lveh == "Z") { zones[liste_accidents[i].zone].stats.Fuite++; }
		 		if(accident.usager_2_lveh == "Z") { zones[liste_accidents[i].zone].stats.Fuite++; }
		 		if(accident.usager_3_lveh == "Z") { zones[liste_accidents[i].zone].stats.Fuite++; }
		 		
		 		// Type d'usage (Conducteur, Passage, Pieton)
		 		if(accident.usager_1_catu == "Cond") { zones[liste_accidents[i].zone].stats.Conducteur++; }
		 		if(accident.usager_1_catu == "Pass") { zones[liste_accidents[i].zone].stats.Passage++; }
		 		if(accident.usager_1_catu == "Piéton") { zones[liste_accidents[i].zone].stats.Pieton++; }
		 		if(accident.usager_2_catu == "Cond") { zones[liste_accidents[i].zone].stats.Conducteur++; }
		 		if(accident.usager_2_catu == "Pass") { zones[liste_accidents[i].zone].stats.Passage++; }
		 		if(accident.usager_2_catu == "Piéton") { zones[liste_accidents[i].zone].stats.Pieton++; }
		 		if(accident.usager_3_catu == "Cond") { zones[liste_accidents[i].zone].stats.Conducteur++; }	
		 		if(accident.usager_3_catu == "Pass") { zones[liste_accidents[i].zone].stats.Passage++; }
		 		if(accident.usager_3_catu == "Piéton") { zones[liste_accidents[i].zone].stats.Pieton++; }
		 		if(accident.usager_4_catu == "Cond") { zones[liste_accidents[i].zone].stats.Conducteur++; }	
		 		if(accident.usager_4_catu == "Pass") { zones[liste_accidents[i].zone].stats.Passage++; }
		 		if(accident.usager_4_catu == "Piéton") { zones[liste_accidents[i].zone].stats.Pieton++; } 		
		 		
		 		// Type de vehicule (Velo, Scooter, Moto, Voiture, VehiculeUtilitaire, BusCar, PoidsLourd, Tram)
		 		if(accident.vehicule_1_cadmin == "Bicy") { zones[liste_accidents[i].zone].stats.Velo++; }
		 		if(accident.vehicule_1_cadmin == "Cyclo") { zones[liste_accidents[i].zone].stats.Scooter++; }
		 		if(accident.vehicule_1_cadmin == "Scoo<=50") { zones[liste_accidents[i].zone].stats.Scooter++; }
		 		if(accident.vehicule_1_cadmin == "Scoo50-125") { zones[liste_accidents[i].zone].stats.Scooter++; }
		 		if(accident.vehicule_1_cadmin == "Scoo>125") { zones[liste_accidents[i].zone].stats.Scooter++; }
		 		if(accident.vehicule_1_cadmin == "Moto50-125") { zones[liste_accidents[i].zone].stats.Moto++; }
		 		if(accident.vehicule_1_cadmin == "Moto>125") { zones[liste_accidents[i].zone].stats.Moto++; }
		 		if(accident.vehicule_1_cadmin == "VL") { zones[liste_accidents[i].zone].stats.Voiture++; }
		 		if(accident.vehicule_1_cadmin == "Voi") { zones[liste_accidents[i].zone].stats.Voiture++; }
		 		if(accident.vehicule_1_cadmin == "VU") { zones[liste_accidents[i].zone].stats.VehiculeUtilitaire++; }
		 		if(accident.vehicule_1_cadmin == "BUS") { zones[liste_accidents[i].zone].stats.BusCar++; }
		 		if(accident.vehicule_1_cadmin == "Car") { zones[liste_accidents[i].zone].stats.BusCar++; }
		 		if(accident.vehicule_1_cadmin == "PL<=7,5") { zones[liste_accidents[i].zone].stats.PoidsLourd++; }
		 		if(accident.vehicule_1_cadmin == "PL>7,5") { zones[liste_accidents[i].zone].stats.PoidsLourd++; }
		 		if(accident.vehicule_1_cadmin == "PLRem") { zones[liste_accidents[i].zone].stats.PoidsLourd++; }
		 		if(accident.vehicule_1_cadmin == "TRSem") { zones[liste_accidents[i].zone].stats.PoidsLourd++; }
		 		if(accident.vehicule_1_cadmin == "Tram") { zones[liste_accidents[i].zone].stats.Tram++; }
		 		
		 		if(accident.vehicule_2_cadmin == "Bicy") { zones[liste_accidents[i].zone].stats.Velo++; }
		 		if(accident.vehicule_2_cadmin == "Cyclo") { zones[liste_accidents[i].zone].stats.Scooter++; }
		 		if(accident.vehicule_2_cadmin == "Scoo<=50") { zones[liste_accidents[i].zone].stats.Scooter++; }
		 		if(accident.vehicule_2_cadmin == "Scoo50-125") { zones[liste_accidents[i].zone].stats.Scooter++; }
		 		if(accident.vehicule_2_cadmin == "Scoo>125") { zones[liste_accidents[i].zone].stats.Scooter++; }
		 		if(accident.vehicule_2_cadmin == "Moto50-125") { zones[liste_accidents[i].zone].stats.Moto++; }
		 		if(accident.vehicule_2_cadmin == "Moto>125") { zones[liste_accidents[i].zone].stats.Moto++; }
		 		if(accident.vehicule_2_cadmin == "VL") { zones[liste_accidents[i].zone].stats.Voiture++; }
		 		if(accident.vehicule_2_cadmin == "Voi") { zones[liste_accidents[i].zone].stats.Voiture++; }
		 		if(accident.vehicule_2_cadmin == "VU") { zones[liste_accidents[i].zone].stats.VehiculeUtilitaire++; }
		 		if(accident.vehicule_2_cadmin == "BUS") { zones[liste_accidents[i].zone].stats.BusCar++; }
		 		if(accident.vehicule_2_cadmin == "Car") { zones[liste_accidents[i].zone].stats.BusCar++; }
		 		if(accident.vehicule_2_cadmin == "PL<=7,5") { zones[liste_accidents[i].zone].stats.PoidsLourd++; }
		 		if(accident.vehicule_2_cadmin == "PL>7,5") { zones[liste_accidents[i].zone].stats.PoidsLourd++; }
		 		if(accident.vehicule_2_cadmin == "PLRem") { zones[liste_accidents[i].zone].stats.PoidsLourd++; }
		 		if(accident.vehicule_2_cadmin == "TRSem") { zones[liste_accidents[i].zone].stats.PoidsLourd++; }
		 		if(accident.vehicule_2_cadmin == "Tram") { zones[liste_accidents[i].zone].stats.Tram++; }
		 		
		 		if(accident.vehicule_3_cadmin == "Bicy") { zones[liste_accidents[i].zone].stats.Velo++; }
		 		if(accident.vehicule_3_cadmin == "Cyclo") { zones[liste_accidents[i].zone].stats.Scooter++; }
		 		if(accident.vehicule_3_cadmin == "Scoo<=50") { zones[liste_accidents[i].zone].stats.Scooter++; }
		 		if(accident.vehicule_3_cadmin == "Scoo50-125") { zones[liste_accidents[i].zone].stats.Scooter++; }
		 		if(accident.vehicule_3_cadmin == "Scoo>125") { zones[liste_accidents[i].zone].stats.Scooter++; }
		 		if(accident.vehicule_3_cadmin == "Moto50-125") { zones[liste_accidents[i].zone].stats.Moto++; }
		 		if(accident.vehicule_3_cadmin == "Moto>125") { zones[liste_accidents[i].zone].stats.Moto++; }
		 		if(accident.vehicule_3_cadmin == "VL") { zones[liste_accidents[i].zone].stats.Voiture++; }
		 		if(accident.vehicule_3_cadmin == "Voi") { zones[liste_accidents[i].zone].stats.Voiture++; }
		 		if(accident.vehicule_3_cadmin == "VU") { zones[liste_accidents[i].zone].stats.VehiculeUtilitaire++; }
		 		if(accident.vehicule_3_cadmin == "BUS") { zones[liste_accidents[i].zone].stats.BusCar++; }
		 		if(accident.vehicule_3_cadmin == "Car") { zones[liste_accidents[i].zone].stats.BusCar++; }
		 		if(accident.vehicule_3_cadmin == "PL<=7,5") { zones[liste_accidents[i].zone].stats.PoidsLourd++; }
		 		if(accident.vehicule_3_cadmin == "PL>7,5") { zones[liste_accidents[i].zone].stats.PoidsLourd++; }
		 		if(accident.vehicule_3_cadmin == "PLRem") { zones[liste_accidents[i].zone].stats.PoidsLourd++; }
		 		if(accident.vehicule_3_cadmin == "TRSem") { zones[liste_accidents[i].zone].stats.PoidsLourd++; }
		 		if(accident.vehicule_3_cadmin == "Tram") { zones[liste_accidents[i].zone].stats.Tram++; }
		 	}
		 }
         
		///*******************************************///
		///*******************************************///
		///*******************************************///
		 
		 
		d3.json("data/accidentologie-paris.geojson", function(data) {
            // create a first guess for the projection
			var center = d3.geoCentroid(data);
			var scale  = 15000;
			var offset = [width/2, height/2];
			var projection = d3.geoMercator().scale(scale).center(center).translate(offset);
			
			// create the path
			var path = d3.geoPath().projection(projection);
			
			// using the path determine the bounds of the current map and use 
			// these to determine better values for the scale and translation
			var bounds  = path.bounds(data);
			var hscale  = scale*width  / (bounds[1][0] - bounds[0][0]);
			var vscale  = scale*height / (bounds[1][1] - bounds[0][1]);
			var scale   = (hscale < vscale) ? hscale : vscale;
			var offset  = [width - (bounds[0][0] + bounds[1][0])/2,
						    height - (bounds[0][1] + bounds[1][1])/2];
			
			// new projection
			projection = d3.geoMercator().center(center).scale(scale).translate(offset);
			path = path.projection(projection);
            
            
            console.log(data.features);
            
            // Contient la liste des centres de chaque zone ainsi que leurs statistiques
            // zones = [ {center: [0]->x, [1]->y; stats: { nbAcc, Indem, BL, BH } } ]
            zones = [];
            
           // Contient la liste des accidents classe par zone
           // liste_accidents = [ {zone: id; accident: detail} ]
            liste_accidents = [];
            
            // Test 1 (filtrage par un intervalle de date)
            //getZones(data.features, 0.01, [75020, 75013], ["2013"], ["04","10"], ["07","22"], ["09:00","12:35"], ["2012-12-23", "2013-01-02"]);
            
            // Test 2 (filtrage par annees - mois - jours en particulier)
            //getZones(data.features, 0.01, [], ["2013","2012"], ["04"], ["07"], [], []);
            
            // Test 3 (sans filtrage)
            getZones(data.features, 0.01, [], [], [], [], [], []);
            
            
            //Set input domain for color scale
            color.domain([0, 200
               //d3.min(data, function(d) { return d.value; }),
               //d3.max(data, function(d) { return d.value; })
            ]);

            var weeksArray = Object.keys(data.features[0]);            
            var France;

            //partie 4
            d3.json("data/arrondissements-ile-de-france.geojson", function(json) {

               d3.select('#week').html(Object.keys(data.features[0])[1]);

               d3.select("#slider").on("input", function() {
                  updateViz(+this.value);
               });

               //On fusionne les donnees avec le GeoJSON des regions
               for (var i = 0; i < data.length; ++i) {
                  for (var j = 0; j < json.features.length; ++j) {
                     //find name dataRegion in json file 
                     var jsonRegion = json.features[j].properties.nom;
                     if (data[i].region == jsonRegion) {
                        json.features[j].properties.tab = Object.values(data[i]);
                        //stop because result found
                        break;
                     }
                  }
               }

               // UPDATE : week and map 
               function updateViz(val) {
                  d3.select('#week').html(weeksArray[val]);
                  drawMap(val);
               };

               France = json;
               
           	   graph = {"zones": zones, "accidents": liste_accidents, "carte": France.features};
			   console.log(graph);
			   
               g.selectAll("path")
                  .data(graph.carte)
                  .enter()
                  .append("path")
                  .attr("d", path)
                  .style("fill", "#9b9b9b");
               
               // Tentative d'ajout des zones
               g.selectAll("circle")
		 		.data(graph.zones)
            	.enter()
            	.append("circle")
            	// Mal dimensionne
            	//.attr("cx", function (d) { return projection(d.center)[0]; })
				//.attr("cy", function (d) { return projection(d.center)[1]; })
				.attr("cx", 800)
				.attr("cy", 200)
				.attr("r", 10)
				.attr("fill", "blue");
            	/*.each(function(d) {
            		var header = d3.select(this);
            		console.log(header);
            		header.attr("r", 1)
            		header.attr("fill", "blue");
            	})*/
            	

               drawMap(1);
            });
            
			
            // FONCTION DRAWMAP STARTS HERE 
            function drawMap(value) {

               carte = g.selectAll("path")
                  .data(graph.carte)
                  .on('mousemove', function(d) {
                     var mouse = d3.mouse(g.node()).map(function(d) {
                        return parseInt(d);
                     });
                     tooltip.classed('hidden', false)
                        .attr('style', 'left:' + (mouse[0] + 15) +
                           'px; top:' + (mouse[1] - 35) + 'px')
                        .html(d.properties.nom + "<br/>" + known(d, value));
                  })
                  .on('mouseout', function() {
                     tooltip.classed('hidden', true);
                  });

               //update map 
               /*carte
                  .attr("class", "update")
                  .style("fill", function(d) {
                     // get value found above
                     var tab = d.properties.tab;
                     if (tab) {
                        return color(tab[value]);
                     } else {
                        // if no value matching, other color 
                        return "#9b9b9b"; //"#ccc";
                     }
                  })*/

               // draw map for the 1st time 
               /*carte.selectAll("path")
                  .enter()
                  .data(graph.carte)
                  .append("path")
                  .attr("class", "enter")
                  .attr("d", path)
                  .style("fill", function(d) {
                     // get value found above
                     var tab = d.properties.tab;
                     if (tab) {
                        return color(tab[value]);
                     } else {
                        // if no value matching, other color 
                        return "#efefef"; //"#ccc";
                     }
                  })*/
            }
         });
      </script>
   </body>
