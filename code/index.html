<!DOCTYPE html>
<html lang="fr">

   <head>
      <meta charset="utf-8">
      <title>Accidentologie Paris</title>
      <script src="https://d3js.org/d3.v4.min.js"></script>
      <style type="text/css">
         /* No style rules here yet */
      </style>
   </head>

   <body>

      <div>
         <input id="slider" type="range" value="1" min="1" max="52" step="1" />
         <span id="week">week</span>
      </div>

      <script>
         var width = 1280,
            height = 720;

         var svg = d3.select("body")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

         var g = svg.append("g");

         var color = d3.scaleQuantize()
            .range(["rgb(237,248,233)",
               "rgb(186,228,179)",
               "rgb(116,196,118)",
               "rgb(49,163,84)",
               "rgb(0,109,44)"
            ]);

         //Define map projection
         var projection = d3.geoConicConformal().center([2.287592,
            48.862725
         ]).scale(
            10000);

         var path = d3.geoPath() // d3.geo.path avec d3 version 3
            .projection(projection);

         var tooltip = d3.select('body').append('div')
            .attr('class', 'hidden tooltip');

         function known(d, week) {
            if (d.properties.tab != undefined) {
               var val = d.properties.tab[week];
            }
            return val
         };
         
         
         // Affecte un accident a une zone
         function affectZone(accident, rayon) {
         	for(var i=0; i < zones.length; ++i) {
         		center = zones[i].center;
         		x = accident.wgs[0];
         		y = accident.wgs[1];
		     	// check coordonnee en X et Y
		     	if(x <= center[0]+rayon && x >= center[0]-rayon && y <= center[1]+rayon && y >= center[1]-rayon) {
	     			liste_accidents.push({ "zone": i, "accident": accident });
	     			return 0;
		     	}
			}
			
			// Aucune zone ne convient, on en creer donc une nouvelle
			zones.push({ "center": accident.wgs, "stats" : { "nbAcc": 0, "Indem": 0, "BL": 0, "BH": 0  } });
			id = zones.length-1;
			liste_accidents.push({ "zone": id, "accident": accident });
         }
         
         
         // Recupere toutes les zones d'accident
         function getZones(accidents, rayon) {
         	// Creation des zones d'accident
	     	for(var i = 0; i < accidents.length; ++i) {
	     		id = affectZone(accidents[i].properties, rayon);
	     	}
	     	// Ajout des statistiques aux zones
	     	for(var i = 0; i < liste_accidents.length; ++i) {
	     		// Mise a jour du nombre d'accident par zone
	     		zones[liste_accidents[i].zone].stats.nbAcc++;
	     		// Mise a jour de la gravite des blessures lors des accidents d'une zone (Indem, BL, BH)
	     		accident = liste_accidents[i].accident;
	     		if(accident.usager_1_grav == "Indem") { zones[liste_accidents[i].zone].stats.Indem++; }
	     		if(accident.usager_1_grav == "BL") { zones[liste_accidents[i].zone].stats.BL++; }
	     		if(accident.usager_1_grav == "BH") { zones[liste_accidents[i].zone].stats.BH++; }
	     		if(accident.usager_2_grav == "Indem") { zones[liste_accidents[i].zone].stats.Indem++; }
	     		if(accident.usager_2_grav == "BL") { zones[liste_accidents[i].zone].stats.BL++; }
	     		if(accident.usager_2_grav == "BH") { zones[liste_accidents[i].zone].stats.BH++; }
	     		if(accident.usager_3_grav == "Indem") { zones[liste_accidents[i].zone].stats.Indem++; }
	     		if(accident.usager_3_grav == "BL") { zones[liste_accidents[i].zone].stats.BL++; }
	     		if(accident.usager_3_grav == "BH") { zones[liste_accidents[i].zone].stats.BH++; }
	     		if(accident.usager_4_grav == "Indem") { zones[liste_accidents[i].zone].stats.Indem++; }
	     		if(accident.usager_4_grav == "BL") { zones[liste_accidents[i].zone].stats.BL++; }
	     		if(accident.usager_4_grav == "BH") { zones[liste_accidents[i].zone].stats.BH++; }
	     	}
         }

		 
         d3.json("data/accidentologie-paris.geojson", function(data) {
            console.log(data.features);
            
            // Contient la liste des centres de chaque zone ainsi que leurs statistiques
            // zones = [ {center: [0]->x, [1]->y; stats: { nbAcc, Indem, BL, BH } } ]
            zones = [];
            
            // Contient la liste des accidents classe par zone
           // liste_accidents = [ {zone: id; accident: detail} ]
            liste_accidents = [];
            
            getZones(data.features, 0.01);
            
            console.log(zones);
            console.log(liste_accidents);
            
            //Set input domain for color scale
            color.domain([0, 200
               //d3.min(data, function(d) { return d.value; }),
               //d3.max(data, function(d) { return d.value; })
            ]);

            var weeksArray = Object.keys(data.features[0]);            
            var France;

            //partie 4
            d3.json("data/arrondissements-ile-de-france.geojson", function(json) {

               d3.select('#week').html(Object.keys(data.features[0])[1]);

               d3.select("#slider").on("input", function() {
                  updateViz(+this.value);
               });

               //On fusionne les donnees avec le GeoJSON des regions
               for (var i = 0; i < data.length; ++i) {
                  for (var j = 0; j < json.features.length; ++j) {
                     //find name dataRegion in json file 
                     var jsonRegion = json.features[j].properties.nom;
                     if (data[i].region == jsonRegion) {
                        json.features[j].properties.tab = Object.values(data[i]);
                        //stop because result found
                        break;
                     }
                  }
               }

               // UPDATE : week and map 
               function updateViz(val) {
                  d3.select('#week').html(weeksArray[val]);
                  drawMap(val);
               };

               France = json

               g.selectAll("path")
                  .data(json.features)
                  .enter()
                  .append("path")
                  .attr("d", path)
                  .style("fill", "steelblue");

               drawMap(1);
            });

            // FONCTION DRAWMAP STARTS HERE 
            function drawMap(value) {

               carte = g.selectAll("path")
                  .data(France.features)
                  .on('mousemove', function(d) {
                     var mouse = d3.mouse(g.node()).map(function(d) {
                        return parseInt(d);
                     });
                     tooltip.classed('hidden', false)
                        .attr('style', 'left:' + (mouse[0] + 15) +
                           'px; top:' + (mouse[1] - 35) + 'px')
                        .html(d.properties.nom + "<br/>" + known(d, value));
                  })
                  .on('mouseout', function() {
                     tooltip.classed('hidden', true);
                  });

               //update map 
               carte
                  .attr("class", "update")
                  .style("fill", function(d) {
                     // get value found above
                     var tab = d.properties.tab;
                     if (tab) {
                        return color(tab[value]);
                     } else {
                        // if no value matching, other color 
                        return "#9b9b9b"; //"#ccc";
                     }
                  })

               // draw map for the 1st time 
               carte.selectAll("path")
                  .enter()
                  .data(France.features)
                  .append("path")
                  .attr("class", "enter")
                  .attr("d", path)
                  .style("fill", function(d) {
                     // get value found above
                     var tab = d.properties.tab;
                     if (tab) {
                        return color(tab[value]);
                     } else {
                        // if no value matching, other color 
                        return "#efefef"; //"#ccc";
                     }
                  })
            }
         });
      </script>
   </body>
